[
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "edge",
			"_gid": "_predicate_edge",
			"_aid": ["edge"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Edge predicate"},
			"_definition": {"iso_639_3_eng": "Edge predicates are used in edges that can be traversed by several paths and that can have several depth levels"},
			"_description": {"iso_639_3_eng": "Predicates are used in two main edge objects: [edges](_edge.md) and [links](_link.md).\n\n[Edges](_edge.md) are used to create *multi-level hierarchical structures* in which a *single edge* may belong to *several graphs* and have *several paths* traverse it."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "functional",
			"_gid": "_predicate_functional",
			"_aid": ["functional"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Functional predicate"},
			"_definition": {"iso_639_3_eng": "Edge predicate that defines the function of the edge relationship"},
			"_description": {"iso_639_3_eng": "Edges have three types of predicates: *functional*, *container* and *bridge*.\n\n*Functional predicates* define the *main function* implemented by the *graph*. An [enumeration predicate](_predicate_enum-of.md), for instance, indicates that the graph contains a controlled vocabulary and that the functional elements in the graph, the nodes connected with the [enumeration predicate](_predicate_enum-of.md), are *valid choices* of the *controlled vocabulary*."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "enum-of",
			"_gid": "_predicate_enum-of",
			"_aid": ["enum-of"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Enumeration of"},
			"_definition": {"iso_639_3_eng": "The source node is a controlled vocabulary element of the destination node."},
			"_description": {"iso_639_3_eng": "The value is a *reference* to a *document* in the form of the document's [handle](_id).\n\nThe document must be a *controlled vocabulary type*, this means that it must be a *node* in a graph *related* with the [enumeration](_predicate_enum-of) [predicate](_predicate), whose root must be among the elements of the set.\n\nWhen you select this [type](_type) you are *required* to include, in the descriptor definition, the data type [kind](_kind). This is a set of *controlled vocabulary types* or *term wildcards* to which the current descriptor's value must conform. Values defined by this type must belong to *at least one* element of the data [kind](_kind) set."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "property-of",
			"_gid": "_predicate_property-of",
			"_aid": ["property-of"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Property of"},
			"_definition": {"iso_639_3_eng": "The source node is a property of the destination node."},
			"_description": {"iso_639_3_eng": "This predicate is used in [object](_type_object) graphs. When two nodes are related with this predicate, it means that the *source* node is a *property* of the *destination* node. This means that the source node should be considered a *property* of the *data structure* defined by the *destination* node. This also implies that the source node represents a *descriptor*."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "field-of",
			"_gid": "_predicate_field-of",
			"_aid": ["field-of"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Field of"},
			"_definition": {"iso_639_3_eng": "The source node is a field of the destination node."},
			"_description": {"iso_639_3_eng": "This [predicate](_predicate.md) can be used to create graphs that can be used in *user interfaces* as *forms* or *tables of content*. The *field-of* predicate indicates that the [source](_from.md) node is a *field of*, or an *element* of the [object](_to.md) node. This denomination is *general*, it *does not* indicate a *precise function* such as [enumeration](_predicate_enum-of.md) or [property](_predicate_property-of.md), it indicates a *membership* that is *general* in nature."}
		}
	},
	
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "container",
			"_gid": "_predicate_container",
			"_aid": ["container"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Container predicate"},
			"_definition": {"iso_639_3_eng": "Non functional edge predicate that acts as a container or category for a set of elements"},
			"_description": {"iso_639_3_eng": "Edges have three types of predicates: *functional*, *container* and *bridge*.\n\n*Container predicates* do not define any function in the graph, they serve as *display sections* or *menu containers* for providing *organisation* to the *graph elements*. For instance a controlled vocabulary of countries could be difided into regions: these regions cannot be selected as elements of the controlled vocabulary, but they can be used as organisers when the numner of available choices is large."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "section-of",
			"_gid": "_predicate_section-of",
			"_aid": ["section-of"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Section of"},
			"_definition": {"iso_639_3_eng": "The source node is a section of the destination node."},
			"_description": {"iso_639_3_eng": "This predicate involves the concept of *section*, a section is a *category* or *heading* that *groups* a *set* of *choices*. For instance, while the [enumeration](_predicate_enum-of) or [property](_predicate_property-of) predicates indicate that the source node is either a valid *controlled vocabulary choice*, or a *descriptor* belonging to the *destination* node, this predicate would indicate that the source node is to be used as a *container* or *disclosure list*. This predicate is used to *group* controlled vocabulary elements or sets of schema descriptors into sections that will be presented as disclosute lists in the user interface when showing forms or lists."}
		}
	},
	
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "bridge",
			"_gid": "_predicate_bridge",
			"_aid": ["bridge"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Bridge predicate"},
			"_definition": {"iso_639_3_eng": "Bridge predicates allow access to a graph by skipping a node"},
			"_description": {"iso_639_3_eng": "Edges have three types of predicates: *functional*, *container* and *bridge*.\n\n*Bridge predicates* can be used to take advantage of an existing graph without needing to duplicate edges. An *existing edge root* can *point* to a *node* using a *bridge predicate*, doing so, the pointed node *becomes* the *root* of another *graph* that can take advantage of the existing graph edges by adding the bridged root to these edges path. This way, for instance, we can have an european countries graph that can take advantahe of the existing ISO 3166 world countries pointing only to the european countries and not needing to duplicate edges."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "bridge-of",
			"_gid": "_predicate_bridge-of",
			"_aid": ["bridge-of"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Bridge of"},
			"_definition": {"iso_639_3_eng": "The source node is a bridge to the destination node."},
			"_description": {"iso_639_3_eng": "This predicate indicates that the *source* node acts as a *bridge* to the *destination* node. This means that the *source* of such relationship should be *hidden* or *skipped* when *traversing* the *path*.\n\nEdges with this predicate are found in both enumeration and structure graphs. With enumerations it is used to allow a *new enumeration root* to *take advantage* of the network belonging to an *existing controlled vocabulary root*, or to *enforce* the *selection* of a *preferred* or *default* element different than the search target. In this case you would create a *bridge edge* with the *existing root* in the `_from`, and the *new root* in the `_to`. With structures such an edge is used to connect the structure data type to its property: in this case you would set the `_from` with the structure *data type* and the `_to` with the *property* of that type."},
			"_examples": {"iso_639_3_eng": "Suppose you have a controlled vocabulary that is exhaustive and has a large number of elements, you want to create a new controlled vocabulary that shares most, but not all the elements of the first enumeration. You normally would need to duplicate the graph nodes and edges and connect them to the new root. By making the old root a bridge to the new root and by adding the new root to the *path* to all relevant edges, it will appear that all the relevant elements belong directly to the new root.\n\nSuppose you have two controlled vocabularies that classify the same information, but enumeration A is partial, while enumeration B is exhaustive. If you want to enforce the use of enumeration B, even passing through enumeration A, you can connect controlled vocabulary A elements with the bridge predicate and connect the related enumeration B elements wuth the *enumeration* predicate. This way when you search for an element in enumeration A, you will get back the corresponding element of enumeration B.\n\nSuppose you have a *data type* that defines a *structure*: you would create a *series of edges* to link the structure *properties* to the *data type* by setting the *property* in the `_from`, the *data type* in the `_to` and the `_predicate_property-of` *predicate* in the `_predicate` field. You would then create an edge linking the *data type* to the desired *root property* with the *data type* in the `_from`, the *root property* in the `_to` and use the `_predicate_bridge-of` in the `_predicate`. When traversing this graph the data type will be ignored."}
		}
	},
	
	
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "link",
			"_gid": "_predicate_link",
			"_aid": ["link"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Link predicate"},
			"_definition": {"iso_639_3_eng": "Link predicates are used in edges that can be traversed by a single path and that have a single level"},
			"_description": {"iso_639_3_eng": "Predicates are used in two main edge objects: [edges](_edge.md) and [links](_link.md).\n\n[Links](_link.md) are used to *connect one or more nodes* to *another node*, this forms a *single level hierarchy*. This type of relationship is equivalent to having an *array of connections* as a *property*, however, implementing this relationship using predicates allows us to *add an additional dimention* to the *relationship*."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "requires",
			"_gid": "_predicate_requires",
			"_aid": ["requires"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Requires"},
			"_definition": {"iso_639_3_eng": "The source node requires the destination node."},
			"_description": {"iso_639_3_eng": "This predicate indicates that the *source* node *requires* the *destination* node. This means that whenever we have the *source* node, we must also have the *destination* node."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate_requires",
			"_lid": "indicator",
			"_gid": "_predicate_requires_indicator",
			"_aid": ["indicator"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Requires indicator"},
			"_definition": {"iso_639_3_eng": "The source node requires the destination node indicator."},
			"_description": {"iso_639_3_eng": "This predicate indicates that the *source* node *requires* the *destination* node, and that the destination node is an *indicator*. This means that whenever we have the *source* node, we must also have the *destination* node.\n\nThis predicate is used to make sure dependent indicators are grouped together and required in a dataset. For instance we could link temperature to precipitation, ensuring that whenever we have temperature we will also include precipitation. In this case precipitation is considered as an indicator."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate_requires",
			"_lid": "metadata",
			"_gid": "_predicate_requires_metadata",
			"_aid": ["metadata"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Requires metadata"},
			"_definition": {"iso_639_3_eng": "The source node requires the destination node metadata."},
			"_description": {"iso_639_3_eng": "This predicate indicates that the *source* node *requires* the *destination* node, and that the destination node is *metadata*. This means that whenever we have the *source* node, we must also have the *destination* node, and that the *destination* node is to be considered *metadata* of the source node.\n\nThis predicate is used to make sure the source node includes the required metadata.  For instance we could link temperature to measurement type, ensuring that whenever we have temperature we will also include the method used to measure it. In this case the method is considered metadata."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "feature",
			"_gid": "_predicate_feature",
			"_aid": ["feature"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Feature predicate"},
			"_definition": {"iso_639_3_eng": "A predicate that indicates a feature"},
			"_description": {"iso_639_3_eng": "Predicates of this kind indicate that the source node is a *feature* of the destination node."}
		}
	},
	{
		"_code": {
			"_nid": "_predicate",
			"_lid": "administrative",
			"_gid": "_predicate_administrative",
			"_aid": ["administrative"]
		},
		"_info": {
			"_title": {"iso_639_3_eng": "Administrative predicate"},
			"_definition": {"iso_639_3_eng": "A predicate that indicates an administrative category"},
			"_description": {"iso_639_3_eng": "Predicates of this kind indicate that the source node is an *administrative category* of the destination node."}
		}
	}
]